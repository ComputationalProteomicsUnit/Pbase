---
title: "Using ensembldb to retrieve protein annotations and map peptide
sequences to genomic coordinates"
output:
  BiocStyle::html_document:
    toc: true
vignette: >
  %\VignetteIndexEntry{Querying protein features}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
  %\VignetteDepends{ensembldb,EnsDb.Hsapiens.v86,BiocStyle}
  %\VignettePackage{Pbase}
---

```{r style, echo = FALSE, results = 'asis', message=FALSE}
BiocStyle::markdown()
```

**Package:** [`Pbase`](http://bioconductor.org/packages/devel/bioc/html/Pbase.html)<br />
**Author:** [Laurent Gatto](http://cpu.sysbiol.cam.ac.uk/), Johannes Rainer <br />
**Last compiled:** `r date()` <br />
**Last modified:** `r file.info("Pbase-with-ensembldb.Rmd")$mtime`

```{r env, message=FALSE, echo=FALSE, cache=FALSE, warning=FALSE}
library("Pbase")
library("ensembldb")
```

# Introduction

This vignette describes how the `r Biocpkg("ensembldb")` package can be used to
retrieve protein annotations and to map peptides within protein sequences to the
genomic coordinates. `EnsDb` databases and packages created by the `ensembldb`
package version > 1.99.0 _can_ provide protein annotations, but don't necessarily
have too. Only `EnsDb` packages created using the Ensembl Perl API contain
protein annotations, while databases created from GTF or GFF files or from
`GRanges` objects or using the `r Biocpkg("AnnotationHub")` don't.

Below we load the `EnsDb` object with for all human genes defined in the Ensembl
database version 86 and use the `hasProteinData` method to evaluate whether
protein annotations are available.

```{r loadlib, message = FALSE}
library(ensembldb)
library(EnsDb.Hsapiens.v86)
## Make a shortcut to the object
edb <- EnsDb.Hsapiens.v86
hasProteinData(edb)
```

# Fetch protein annotations from the database

`ensembldb` provides the `proteins` method to fetch protein annotations from an
`EnsDb` database (along eventual transcript or gene annotation) and return the
results as a `data.frame`, `DataFrame` or `AAStringSet`. Below we use that
function to retrieve all proteins encoded by the gene _ZBTB16_. We use a
`GenenameFilter` to select entries for that gene. In the simple example below
only protein annotations were retrieved (i.e. the Ensembl protein ID, the amino
acid sequence, the ID of the transcript encoding the protein and the gene name;
the latter two stored in the `AAStringSet`'s `mcols`), but `EnsDb`s provide in
addition also the mapping between Ensembl protein IDs and Uniprot IDs and all
protein domains within the protein sequence. For more information on available
filters, methods and annotation columns see the `ensembldb` vignette.

```{r proteins_method}
prts <- proteins(edb, filter = GenenameFilter("ZBTB16"),
                 return.type = "AAStringSet")
prts

## Get access to the additional annotation data
mcols(prts)

```

In `Pbase`, a `Proteins` method is also implemented for `EnsDb` objects that
enables to load a `Proteins` object from an `EnsDb` database and optionally load
all protein domains as peptide ranges in the `pranges` slot (using the
`loadProteinDomains` parameter which is by default `TRUE`).

```{r Proteins_method, message = FALSE}
library(Pbase)
zbtb16 <- Proteins(edb, filter = GenenameFilter("ZBTB16"))
```

The proteins' sequences are stored in the `aa` slot and the protein domains in
the `pranges` slot:

```{r Proteins_aa_pranges}
## Get the protein sequences.
aa(zbtb16)

## Get the protein domains stored as peptide features.
pranges(zbtb16)
```

In a similar fashion we can also load all proteins encoded on chromosome Y from
the database, or even all human proteins if no filter is provided.

```{r Proteins_on_Y}
pr_y <- Proteins(edb, filter = SeqnameFilter("Y"))
length(pr_y)
```

# Protein and genome data

`EnsDb` databases provide both, protein annotations, and also gene/transcript
annotations along with their genomic coordinates. Thus, we can use the `EnsDb`
database for the mapping of the peptide features within the `Proteins` to the
genome. The `Proteins` object has already the ID of the encoding transcript
available in the metadata column `tx_id`. These additional, protein related,
annotation columns can be accessed with the `acols` method (in contrast to the
`pcols` method that is used to access metadata columns of the peptide features
of each protein).

```{r genome_map_tx}
acols(zbtb16)
```

We can use these IDs as input for a `TxidFilter` to fetch the genomic
coordinates of the transcripts' coding regions (i.e. the exons and parts of
exons forming the coding region) from the `EnsDb`. Note that in contrast to the
`cdsBy` method used below, the `exonsBy` method would return all exons, thus
also the 5' and 3' UTR. Note also that we have to re-order the resulting
`GRangesList` as the results don't necessarily have to be ordered by the `tx_id`
used in the query.

```{r genome_map_cdsBy}
zbtb16_cds <- cdsBy(edb,
                    filter = TxidFilter(acols(zbtb16)$tx_id))
## Reorder the tx
zbtb16_cds <- zbtb16_cds[acols(zbtb16)$tx_id]
## The exons for the first transcript.
zbtb16_cds[[1]]
```

With this information available we can simply use `Pbase`'s `mapToGenome`
method to map the protein domains within a protein back to genomic coordinates.

```{r genome_map_mapToGenome}
## For mapToGenome
res <- mapToGenome(zbtb16[1], zbtb16_cds[1])
res
```

The `GRanges` in the resulting `GRangesList` specify the genomic regions in
which the individual peptide features are encoded. The `group` column in the
`GRanges`' `mcols` links ranges encoding the same peptide feature, e.g. if a
feature is encoded by a RNA sequence spanning 2 or more exons, the corresponding
genomic regions have the same index in the `group` column. The protein domain
_PS50157_ is for example encoded by a sequence within 2 exons of the transcript _ENST00000335953_.

```{r genome_map_group_col}
## Extract the GRanges associated with "group 4"
res[[1]][res[[1]]$group == 4]
```

With this information available we can plot the transcript along with the
peptide feature on the genomic scale. The figure below hence shows the
transcript and all of the protein domains within the protein encoded by that transcript.

```{r plot-zbtb16-with-prot-domains, fig.align = 'center'}

## Define a genome axis track
gat <- GenomeAxisTrack()
## Get a GRanges for the specific transcript
trt <- getGeneRegionTrackForGviz(edb, filter = TxidFilter(res[[1]]$tx_id[1]))

## At last adding the protein domain name as column "id" to the mcols
res[[1]]$id <- names(res[[1]])

## Plotting everything
plotTracks(list(gat,
                GeneRegionTrack(trt, name = "tx"),
                AnnotationTrack(res[[1]], groupAnnotation = "id",
                                just.group = "above",
                                name = "Protein domains")),
           transcriptAnnotation = "transcript")

```



# Session information

```{r si}
sessionInfo()
```
