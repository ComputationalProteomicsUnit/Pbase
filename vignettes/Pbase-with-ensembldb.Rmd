---
title: "Using ensembldb to retrieve protein annotations and map peptide
sequences to genomic coordinates"
output:
  BiocStyle::html_document:
    toc: true
vignette: >
  %\VignetteIndexEntry{Querying protein features}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
  %\VignetteDepends{ensembldb,EnsDb.Hsapiens.v86,BiocStyle}
  %\VignettePackage{Pbase}
---

```{r style, echo = FALSE, results = 'asis', message=FALSE}
BiocStyle::markdown()
```

**Package:** [`Pbase`](http://bioconductor.org/packages/devel/bioc/html/Pbase.html)<br />
**Author:** [Laurent Gatto](http://cpu.sysbiol.cam.ac.uk/) [Johannes Rainer] <br />
**Last compiled:** `r date()` <br />
**Last modified:** `r file.info("Pbase-with-ensembldb.Rmd")$mtime`

```{r env, message=FALSE, echo=FALSE, cache=FALSE, warning=FALSE}
library("Pbase")
library("ensembldb")
```

## Introduction

This vignette describes how the `r Biocpkg("ensembldb")` package can be used to
retrieve protein annotations and to map peptides within protein sequences to the
genomic coordinates. `EnsDb` databases and packages created by the `ensembldb`
package version > XXX _can_ provide protein annotations, but don't necessarily
have too. Only `EnsDb` packages created using the Ensembl Perl API contain
protein annotations, while databases created from GTF or GFF files or from
`GRanges` objects or using the `r Biocpkg("AnnotationHub")` don't.

Below we load the `EnsDb` object with for all human genes defined in the Ensembl
database version 86 and use the `hasProteinData` method to evaluate whether
protein annotations are available.

```{r loadlib, message = FALSE}
library(ensembldb)
library(EnsDb.Hsapiens.v86)
## Make a shortcut to the object
edb <- EnsDb.Hsapiens.v86
hasProteinData(edb)
```

## Fetch protein annotations from the database

`ensembldb` provides the `proteins` method to fetch protein annotations from an
`EnsDb` database (along eventual transcript or gene annotation) and return the
results as a `data.frame`, `DataFrame` or `AAStringSet`. Below we use that
function to retrieve all proteins encoded by the gene _ZBTB16_. We use a
`GenenameFilter` to select entries for that gene. In the simple example below
only protein annotations were retrieved (i.e. the Ensembl protein ID, the amino
acid sequence, the ID of the transcript encoding the protein and the gene name;
the latter two stored in the `AAStringSet`'s `mcols`), but `EnsDb`s provide in
addition also the mapping between Ensembl protein IDs and Uniprot IDs and all
protein domains within the protein sequence. For more information on available
filters, methods and annotation columns see the `ensembldb` vignette.

```{r proteins_method}
prts <- proteins(edb, filter = GenenameFilter("ZBTB16"),
                 return.type = "AAStringSet")
prts

## Get access to the additional annotation data
mcols(prts)

```

In `Pbase`, a `Proteins` method is also implemented for `EnsDb` objects that
enables to load a `Proteins` object from an `EnsDb` database and optionally load
all protein domains as peptide ranges in the `pranges` slot (using the
`loadProteinDomains` parameter which is by default `TRUE`).

```{r Proteins_method, message = FALSE}
library(Pbase)
zbtb16 <- Proteins(edb, filter = GenenameFilter("ZBTB16"))
```

The proteins' sequences are stored in the `aa` slot and the protein domains in
the `pranges` slot:

```{r Proteins_aa_pranges}
## Get the protein sequences.
aa(zbtb16)

## Get the protein domains stored as peptide features.
pranges(zbtb16)
```

In a similar fashion we can also load all proteins encoded on chromosome Y from
the database, or even all human proteins if no filter is provided.

```{r Proteins_on_Y}
pr_y <- Proteins(edb, filter = SeqnameFilter("Y"))
length(pr_y)
```

## Protein and genome data

`EnsDb` databases provide both, protein annotations, and also gene/transcript
annotations along with their genomic coordinates. Thus, we can use the `EnsDb`
database for the mapping of the peptide features within the `Proteins` to the
genome. The `Proteins` object has already the ID of the encoding transcript
available in the metadata column `tx_id`. These additional, protein related,
annotation columns can be accessed with the `acols` method (in contrast to the
`pcols` method that is used to access metadata columns of the peptide features
of each protein).

```{r genome_map_tx}
acols(zbtb16)
```

We can use these IDs as input for a `TxidFilter` to fetch the genomic
coordinates of the transcripts' coding regions (i.e. the exons and parts of
exons forming the coding region) from the `EnsDb`. Note that in contrast to the
`cdsBy` method used below, the `exonsBy` method would return all exons, thus
also the 5' and 3' UTR. Note also that we have to re-order the resulting
`GRangesList` as the results don't necessarily have to be ordered by the `tx_id`
used in the query.

```{r genome_map_cdsBy}
zbtb16_cds <- cdsBy(edb,
                    filter = TxidFilter(acols(zbtb16)$tx_id))
## Reorder the tx
zbtb16_cds <- zbtb16_cds[acols(zbtb16)$tx_id]
## The exons for the first transcript.
zbtb16_cds[[1]]
```

With this information available we can simply use `Pbase`'s `mapToGenome`
method to map the protein domains within a protein back to genomic coordinates.

```{r genome_map_mapToGenome}
## For mapToGenome
res <- mapToGenome(zbtb16[1], zbtb16_cds[1])

```

```{r dev}
## Development block!
pObj <- zbtb16[1]
grObj <- zbtb16_cds[[1]]


```


TODO:
+ [ ] fix the `mapToGenome` method.
+ [ ] implement a `mapToGenome` with `Proteins` and `EnsDb`?


DO
+ map to genomic coordinates.
+ map to genomic coordinates without a `GRanges`.
+ plot the domains within protein sequence.

## Visualisation with `r Biocpkg("Gviz")` and `r Biocpkg("Pviz")`

## Genomic coordinates and peptide mappings using `r Biocpkg("ensembldb")`

The `r Biocpkg("ensembldb")` package can be used as an alternative to `r
Biocpkg("biomaRt")` package to fetch genomic coordinates of transcript
models. `EnsDB` databases built by the `ensembldb` package encapsule genomic
coordinates of all genes/transcripts and exons of an organism thus, in contrast
to `biomaRt`, enabling offline analyses. Because `EnsDb` databases contain
annotations from a certain Ensembl release reproducible analyses are
guaranteed. Since Bioconductor version 3.4, `ensembldb` supports adding protein
annotations to `EnsDb` databases hence allowing to directly query transcripts
encoding certain proteins.

Below we load the `EnsDb` package containing all human gene annotations from
Ensembl version 86. We change also the default chromosome naming style from
_Ensembl_ to _UCSC_ (e.g. _chrX_ instead of _X_). While this is not necessary
for most analyses, it ensures that the retrieved sequence names are in the
format expected by the `Gviz` package which will be used later for plotting the
transcripts.

```{r load_ensdb}
library(ensembldb)
library(EnsDb.Hsapiens.v86)
edb <- EnsDb.Hsapiens.v86
## Change sequence naming style
seqlevelsStyle(edb) <- "UCSC"
```

We can now fetch transcripts encoding the proteins providing their Uniprot IDs
with a `UniprotidFilter` (see the vignettes of the `ensembldb` for a complete
listing of all supported filters. We use in addition a `SeqnameFilter`
to ensure that we're only fetching transcripts from the reference sequences and
not from patched chromosomes or chromosome variants. Note that we have to use
here _UCSC-style_ chromosome names, since we changed the `seqlevelsStyle` above.

```{r fetch_tx}
p_tx <- transcripts(edb,
                    filter = list(UniprotidFilter(seqnames(p)),
                                  SeqnameFilter(paste0("chr", c(1:22, "X", "Y")))))
p_tx
```

Each of the proteins can be encoded by more than one protein. Also, for one
protein (_P04075-2_) we don't have a mapping to a transcript.

```{r table_tx}
table(p_tx$uniprot_id)
```

Below we use the `exonsBy` method to retrieve the transcript models for the
transcripts associated to the proteins. While this returns all exons (including
non-coding exons), we could alternatively use the `cdsBy` method to retrieve
just the genomic coordinates of the transcripts' coding regions.

```{r exonsBy}
exns <- exonsBy(edb, filter = TxidFilter(acols(p)$ENST))
exns
```

### Mapping peptides to genomic coordinates

To map peptides within the protein sequence to genomic coordinates, we need
first the genomic coordinates of the transcript's coding region. We use the
`cdsBy` method to fetch that information, but have to re-order the resulting
`GRangesList` as results are not returned in the same order than the transcript
IDs that we submitted.

```{r cdsBy}
p_cds <- cdsBy(edb, filter = TxidFilter(acols(p)$ENST))
p_cds <- p_cds[acols(p)$ENST]
p_cds
```

Ranges within protein sequences of the `Proteins` object can now be mapped to
genomic coordinates with the `mapToGenome` method.

```{r ens_mapToGenome}
res_2 <- mapToGenome(p[5], p_cds[5])
## Does not work because the function expects the mcols to be in a certain order

tx5 <- p_cds[[5]]
p5 <- p[5]
## Check if we would get the same protein sequence from Ensembl:
p5_ens <- proteins(edb, filter = TxidFilter(tx5$tx_id[1]),
                   return.type = "AAStringSet")

## Compare the protein sequences:


## Why it's not working???
p_grt <- getGeneRegionTrackForGviz(edb, filter = TxidFilter(acols(p)$ENST))
p_grt <- split(p_grt, p_grt$transcript)
p_grt <- p_grt[acols(p)$ENST]
res_3 <- mapToGenome(p[5], p_grt[5])
```

### Plotting

Plotting of transcript models on genomic coordinates can be performed with the
functionality from the `r Biocpkg("Gviz")` package. The `ensembldb` package
provides the dedicated `getGeneRegionTrackForGviz` to fetch transcript models in
the format supported by `Gviz`.


## Dealing with multiple transcipts per protein

```{r}
k <- 6
seqnames(p)[k]
```
In the code chunk below, we remind ourselves that, querying the
Ensembl Biomart server for `r seqnames(p)[k]`, we obtain several
possible transcript identifiers, including the identifier of interest
`r acols(p)$ENST[k]`.

```{r remindbm}
sel <- bm$uniprot_swissprot == seqnames(p)[k]
bm[sel, ]
acols(p)$ENST[k]
```

Let's fetch the coordinates of all possible transcipts, making sure
that the names of the Ensembl identifiers are used to name the `grl`
ranges (using `use.names = TRUE`).

```{r etris2grl2}
eid <- bm[sel, 3]
names(eid) <- bm[sel, 1]
eid

grl <- etrid2grl(eid, ens, use.names = TRUE)
pcgrl <- proteinCoding(grl)
```

```{r plot5}
plotAsGeneRegionTrack(pcgrl)
```

### Descriminating transcripts

We extract the transcript sequences, translate them into protein
sequences and align each to our protein sequence (originally imported
from the fasta database, see `?Proteins` for the construction of `p`).

```{r getseq2, warning=FALSE}

lseq <- lapply(getSeq(BSgenome.Hsapiens.NCBI.GRCh38, pcgrl),
               function(s) translate(unlist(s)))

laln <- sapply(lseq, pairwiseAlignment, aa(p[k]))
sapply(laln, nmatch)/width(aa(p[k]))
```

```{r ki, echo=FALSE}
ki <- which.max(sapply(laln, nmatch))
```
We see that transcript number `r ki`, `r eid[ki]`, perfectly aligns
with our protein sequence. This is also the transcipt that corresponds
to the curated Ensembl transcript in `acols(p)$ENST`.

```{r checkk}
ki <- which.max(sapply(laln, nmatch))
stopifnot(eid[ki] == acols(p)$ENST[k])
```

```{r map2}
res <- pmapToGenome(p[k], pcgrl[ki])
```

As shown on the next figure, peptides that span over exon junctions
are grouped together and, below, colour-coded.

```{r pepcoords2}
plotAsAnnotationTrack(res[[1]], pcgrl[[ki]])
```

One can also apply a many-to-one mapping approach to all proteins in
the `p` object and all the transcripts identifiers fetched with
`etrid2grl` as shown below.

```{r coordall}
alleid <- bm[, 3]
names(alleid) <- bm[, 1]
grl <- etrid2grl(alleid, ens, use.names = TRUE)
pcgrl <- proteinCoding(grl)
res <- mapToGenome(p, pcgrl)
length(res)
```

The messages indicate that one protein accession number was not found
in the `pcgrl` ranges (no transcript was found) and several mapping
failed. In total, we obtain `r length(res)` mapping for
`r length(unique(names(pcgrl)))` protein accession numbers.

## Session information

```{r si}
sessionInfo()
```

<!-- #### TODO -->

<!-- Check spectra. Describe how data tracks can be used to overlay -->
<!-- additional information, such as quantitation data, identification -->
<!-- scores, coverage, ... -->
