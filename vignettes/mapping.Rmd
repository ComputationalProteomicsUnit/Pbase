---
title: "Mapping experimental MS data to genomic coordinates"
output:
  BiocStyle::html_document:
    toc: true
---

<!--
%\VignetteEngine{knitr::rmarkdown}
%\VignetteIndexEntry{mapping}
%\VignettePackage{Pbase}
-->

```{r style, echo = FALSE, results = 'asis', message=FALSE}
BiocStyle::markdown()
```

**Package:** [`Pbase`](http://bioconductor.org/packages/devel/bioc/html/Pbase.html)<br />
**Author:** [Laurent Gatto](http://cpu.sysbiol.cam.ac.uk/) <br />
**Last compiled:** `r date()` <br />
**Last modified:** `r file.info("mapping.Rmd")$mtime`

```{r env, message=FALSE, echo=FALSE, cache=FALSE, warning=FALSE}
library("Gviz")
library("Pbase")
library("Biostrings")
library("biomaRt")
library("BSgenome.Hsapiens.NCBI.GRCh38")
library("TxDb.Hsapiens.UCSC.hg38.knownGene")
library("ggplot2")
```

## Introduction

The aim of this vignette is to document the mapping of proteins and
the tandem mass spectrometry-derived peptides to genomic locations.

```{r schema, echo=FALSE, fig.cap='Mapping proteins to a genome reference.', fig.align='center'}
par(mar = rep(0, 4),
    oma = rep(0, 4))

xlim <- c(0, 10)
ylim <-c(5.05, 10.25)

plot(0, type = "n", axes = FALSE,
     xlab = "", ylab = "",
     xlim = xlim,    
     ylim = ylim)

y <- 10

g <- c(0, 10)

exons <- list(c(0, 2),
              c(4.5, 5),
              c(6, 7.1),
              c(9, 10))

trans <- list(c(1, 2, 3, 4),
              c(1, 3, 4),
              c(1, 4))

prot <- list(exons[[1]] + c(0.5, 0), ## 5'UTR
             exons[[3]],
             exons[[4]] + c(0, -0.5)) ## 3'UTR

peps <- list(c(1, 1.29),
             c(6.1, 6.3), c(6.85, 7),
             c(9.1, 9.25))


rect(g[1], y-0.25, g[2], y+0.25, col = "black")
abline(h = y, lwd = 2)
text(g[1], y+0.25, expression(g[s]), pos = 3)
text(g[2], y+0.25, expression(g[e]), pos = 3)
text(0-0.26, y, "G", pos = 3)

abline(v = c(unlist(exons),
           unlist(prot),
           unlist(peps)),
       lty = "dotted",
       col = "lightgrey")

y <- y - 1
for (i in 1:length(trans)) {
    tr <- trans[[i]]
    abline(h = y, lty = "dotted")
    ## text(0-0.26, y, expression(T[x]), pos = 3)
    text(0-0.26, y,
         substitute(paste("T", list(x)), list(x = i)),
         pos = 3)
    for (j in 1:length(tr)) {
        e1 <- exons[[tr[j]]][1]
        e2 <- exons[[tr[j]]][2]
        rect(e1, y-0.25, e2, y+0.25, col = "grey")
        if (i == 1) {
            text(e1, y+0.25, expression(e[s]^i), pos = 3)
            text(e2, y+0.25, expression(e[e]^i), pos = 3)
        }
        text(mean(c(e1, e2)), y, paste0("i = ", tr[j]), cex = .7)
    }
    y <- y - .6
}

y <- y - .4

abline(h = y, lty = "dotted")
text(0-0.26, y, expression(P), pos = 3)
for (i in 1:length(prot)) {
    pr <- prot[[i]]
    rect(pr[1], y - 0.25,
         pr[2], y + 0.25,
         col = "steelblue")
    text(pr[1], y + 0.25, expression(p[s]^j), pos = 3)
    text(pr[2], y + 0.25, expression(p[e]^j), pos = 3)
    text(mean(c(pr[1], pr[2])), y, paste0("j = ", i), cex = .7)
}
y <- y - .75

## concat protein
## center
x <- mean(xlim)
protlen <- sum(sapply(prot, diff))
X0 <- x0 <- x - protlen/2 ## left start

abline(h = y, lty = "dotted")
text(0-0.26, y, expression(P), pos = 3)

for (i in 1:length(prot)) {
    pr <- prot[[i]]
    .pr1 <- x0
    .pr2 <- x0 + (pr[2] - pr[1])
    rect(.pr1, y - 0.25,
         .pr2, y + 0.25,
         col = "steelblue")
    segments(.pr1, y + 0.25, pr[1], y + .75 - .25, lty = "dotted")
    segments(.pr2, y + 0.25, pr[2], y + .75 - .25, lty = "dotted")
    text(mean(c(.pr1,.pr2)), y, paste0("j = ", i), cex = .7)
    x0 <- .pr2
}

text(X0, y, expression(1), pos = 2)
text(X0 + protlen, y, expression(L[P]), pos = 4)

## pos and length
relpeps <- list(c(0.5, 0.29),
                ## 1.% is length of exon 1
                c(1.5 + 0.1, 0.2),
                c(1.5 + 0.85, 0.15),
                ## 1.1 is length of exon 2
                c(1.5 + 1.1 + 0.1, 0.15))

for (i in 1:length(relpeps)) {
    rp <- relpeps[[i]]
    pep <- peps[[i]]
    rect(X0 + rp[1], y - 0.25,
         X0 + rp[1] + rp[2], y + 0.25,
         col = "#FFA50450", lwd = 0)
    segments(X0 + rp[1], y - 0.25,
             pep[1], y - .75 + .25, lty = "dotted")
    segments(X0 + rp[1] + rp[2], y - 0.25,
             pep[2], y - .75 + .25, lty = "dotted")
}
y <- y - .75


abline(h = y, lty = "dotted")
text(0-0.26, y, expression(Pi), pos = 3)
for (i in 1:length(peps)) {
    pep <- peps[[i]]
    rect(pep[1], y - 0.25,
         pep[2], y + 0.25,
         col = "#FFA504FF")
    text(pep[1], y + 0.25, expression(pi[s]^k), pos = 3, cex = .7)
    text(pep[2], y + 0.25, expression(pi[e]^k), pos = 3, cex = .7)
    text(mean(c(pep[1], pep[2])), y-0.35, paste0("k = ", i), cex = .8)
}
```

## Protein and genome data

We will use a small `Proteins` object from the `r Biocpkg("Pbase")`
package to illustrate how to retrieve genome coordinates and map a
peptides back to genomic coordinates. See the `Pbase-data` vignette
for an introduction to `Proteins` data. The main information needed in
this vignette consists of protein UniProt identifiers and a set of
peptides positions along the protein sequence.


```{r p, message=FALSE}
library("Pbase")
data(p)
p
seqnames(p)
```

```{r startend}
pcols(p)[1, c("start", "end")]
```

We will also require an identifier relating the protein feature of
interest to the genome. Below, we use `r Biocpkg("biomaRt")` to query
the matching Ensembl transcript identifier. We start by create a
`Mart` object that stores the connection details to the latest human
Ensembl biomart server.

```{r bm, cache=TRUE, message=FALSE}
library("biomaRt")
ens <- useMart("ensembl", "hsapiens_gene_ensembl")
ens

bm <- select(ens, keys = seqnames(p),
             keytype = "uniprot_swissprot_accession",
             columns = c(
                 "uniprot_swissprot_accession",
                 "hgnc_symbol",
                 "ensembl_transcript_id"))

bm
```

As can be seen, there can be multiple transcripts for one protein
accession. We have defined the transcripts of interest for our
proteins in `p`; they are stored as protein elements metadata:

```{r enst}
acols(p)$ENST
```

## Genomic transcript coordinates

The `etrid2grl` function takes our transcript identifiers and will
query the Ensembl biomart server (note the `ens` argument) and return
a `GRangesList` object. For each of Ensembl transcript identifiers
provided as input, we have the genomic coordinates of that
transcript's exons as well as additional information such as the type
of exons (protein coding or untranslated region).

```{r etris2grl}
grl <- etrid2grl(acols(p)$ENST, ens)
all.equal(names(grl), acols(p)$ENST,
          check.attributes=FALSE)
grl
```

We also need to retain only coding exons and discard untranslated
regions for later peptide mapping, using the `proteinCoding` function.

```{r pc}
pcgrl <- proteinCoding(grl)
pcgrl
```

## Visualisation with `r Biocpkg("Gviz")` and `r Biocpkg("Pviz")`

### Peptides along proteins

```{r echo=FALSE}
pp <- p[5]
n <- elementLengths(pranges(pp))
pepstring <- paste(unique(pcols(pp)[[1]]$pepseq), collapse = ", ")
```

The peptides that have been experimentally observed are available as
ranges (coordinates) along the protein sequences. For example, below,
we isolate and visualise the `r n` peptides (`r pepstring`) have been
identified for our protein of interest `r seqnames(p)[5]`.

```{r}
sort(pranges(p)[5])
plot(p[5])
```

### Exons along the genome

We can also plot the transcript regions inluding (`grl`) or exclusing
(`pcgrl`) the untranslated regions.

```{r}
plotTracks(list(GeneRegionTrack(grl[[5]]),
                GeneRegionTrack(pcgrl[[5]])))
```

To add context, we add the ideogram of chromosome X and an axis.

```{r gvizfig, fig.align='center', cache=TRUE}
chrom(grl[[5]])

grTrack <- GeneRegionTrack(grl[[5]],
                           name = acols(p)$ENST[5])
ideoTrack <- IdeogramTrack(genome = "hg38",
                           chromosome = "chrX")
axisTrack <- GenomeAxisTrack()
plotTracks(list(ideoTrack, axisTrack, grTrack),
           add53 = TRUE, add35 = TRUE)
```

## Mapping peptides back to the genome

The aim of this document is to document the mapping of peptides,
i.e. ranges along a protein sequence to ranges along the genome
reference. In other words, our aim is the convert protein coordinates
to genome coordinates.


### Comparing protein and translated DNA sequences

The first check that we want to implement is to verify that we can
regenerate the protein amino acid sequence from the genome regions
that we have extracted.

We also need the actual genome sequence (so far, we have only dealt
with regions and features). The exons coordinates have been retrieved
from the latest Ensembl release, which is based on the human genome
assembly `GRCh38`. We will use a genome package that is based on the
same reference genome, namely `r Biocannopkg("BSgenome.Hsapiens.NCBI.GRCh38")`.

We need to make sure that the chromosomes are named the same way in
the genome sequence data and our genomics ranges (`"chrX"`, as seen
above).

```{r protfromgenome}
library("BSgenome.Hsapiens.NCBI.GRCh38")
head(seqnames(BSgenome.Hsapiens.NCBI.GRCh38))
if (!"chr1" %in% seqnames(BSgenome.Hsapiens.NCBI.GRCh38))
    seqnames(BSgenome.Hsapiens.NCBI.GRCh38) <-
        paste0("chr", seqnames(BSgenome.Hsapiens.NCBI.GRCh38))
head(seqnames(BSgenome.Hsapiens.NCBI.GRCh38))
```

Once we have extracted the actual sequences, we must also make sure
that we we reverse the sequences in case out genomic features are on
the reverse strand. We the combine (`unlist`) the exons (coding
sequences only, `pcgrl`) and translate then into a protein sequence.


```{r aaseq}
s <- getSeq(BSgenome.Hsapiens.NCBI.GRCh38, pcgrl[[5]])
s

if (isReverse(pcgrl[[5]]))
    s <- rev(s)

aaseq <- translate(unlist(s))
aaseq
```

We verify that the translated genome sequence and the protein squence
we started with match by aligning them.

```{r aln}
writePairwiseAlignments(pairwiseAlignment(aa(p[5]), aaseq))
```

### Calculating new coordinates

We can now calculate the peptide coordinate along the genome using the
position of the peptides along the protein (in `p`) and the position
of the exons of the protein's transcript along the genome (in `pcgrl`)
using the `mapToGenome` function.

```{r}
res <- mapToGenome(p[5], pcgrl[[5]])
res
```

### Plotting

Based on the new peptide genomic coordinates, it is now
straightforward to create a new `AnnotationTrack` and add it the the
track visualisation.

```{r pepcoords, fig.align='center'}

pepTrack <- AnnotationTrack(start = start(res),
                            end = end(res),
                            chr = chrom(res),
                            strand = strand(res),
                            id = mcols(res)$pepseq,
                            name = paste0(seqnames(p[5]),
                                " peptides"))



plotTracks(list(ideoTrack, axisTrack, grTrack, pepTrack),
           groupAnnotation = "id",
           just.group = "below",
           fontsize.group = 9,
           add53 = TRUE, add35 = TRUE)
```

### Detailed annotation track

Finally, we customise the figure by adding a track with the $MS^2$
spectra. The raw data used to search the protein database an create
`p` are available as an `MSnExp` object. 

```{r msmsspectra, fig.align='center'}
data(pms)

library("ggplot2")
details <- function(identifier, ...) {
    p <- plot(pms[[as.numeric(identifier)]], full=TRUE, plot=FALSE) + ggtitle("") 
    p <- p + theme_bw() + theme(axis.text.y = element_blank(),
                                axis.text.x = element_blank()) + 
                                labs(x = NULL, y = NULL)
    print(p, newpage=FALSE)
}

deTrack <- AnnotationTrack(start = start(res),
                           end = end(res),
                           genome = "hg38", chromosom = "chrX",
                           id = pcols(p)[[5]]$acquisitionNum,
                           name = "MS2 spectra",
                           stacking = "squish", fun = details)


plotTracks(list(ideoTrack, axisTrack, deTrack, grTrack),
           add53 = TRUE, add35 = TRUE)
```

#### TODO

Check spectra. Describe how data tracks can be used to overlay
additional information, such as quantitation data, identification
scores, coverage, ...

## Session information

```{r si}
sessionInfo()
```
