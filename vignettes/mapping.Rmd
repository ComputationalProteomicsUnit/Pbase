---
title: "Mapping experimental MS data to genomic coordinates"
output:
  BiocStyle::html_document:
    toc: true
---


<!--
%\VignetteEngine{knitr::knitr}
%\VignetteIndexEntry{mapping}
%\VignettePackage{Pbase}
-->

```{r style, echo = FALSE, results = 'asis', message=FALSE}
BiocStyle::markdown()
```

<hr />

Author: [Laurent Gatto](http://cpu.sysbiol.cam.ac.uk/)

Compilation date: `r Sys.Date()`

<hr />


Mapping proteins to their genomic coordinates
=============================================

```{r, env, message=FALSE, echo=FALSE, cache=FALSE, warning=FALSE}
library("Gviz")
library("Pbase")
library("Biostrings")
library("biomaRt")
library("BSgenome.Hsapiens.UCSC.hg19")
library("TxDb.Hsapiens.UCSC.hg19.knownGene")
library("ggplot2")
```

## Introduction

The aim of this document is to document the mapping of proteins and
the tandem mass spectrometry derived peptides to genomic locations.

```{r schema, echo=FALSE, fig.cap='Mapping proteins to a genome reference.', fig.align='center'}
par(mar = rep(0, 4),
    oma = rep(0, 4))

xlim <- c(0, 10)
ylim <-c(5.05, 10.25)

plot(0, type = "n", axes = FALSE,
     xlab = "", ylab = "",
     xlim = xlim,    
     ylim = ylim)

y <- 10

g <- c(0, 10)

exons <- list(c(0, 2),
              c(4.5, 5),
              c(6, 7.1),
              c(9, 10))

trans <- list(c(1, 2, 3, 4),
              c(1, 3, 4),
              c(1, 4))

prot <- list(exons[[1]] + c(0.5, 0), ## 5'UTR
             exons[[3]],
             exons[[4]] + c(0, -0.5)) ## 3'UTR

peps <- list(c(1, 1.29),
             c(6.1, 6.3), c(6.85, 7),
             c(9.1, 9.25))


rect(g[1], y-0.25, g[2], y+0.25, col = "black")
abline(h = y, lwd = 2)
text(g[1], y+0.25, expression(g[s]), pos = 3)
text(g[2], y+0.25, expression(g[e]), pos = 3)
text(0-0.26, y, "G", pos = 3)

abline(v = c(unlist(exons),
           unlist(prot),
           unlist(peps)),
       lty = "dotted",
       col = "lightgrey")

y <- y - 1
for (i in 1:length(trans)) {
    tr <- trans[[i]]
    abline(h = y, lty = "dotted")
    ## text(0-0.26, y, expression(T[x]), pos = 3)
    text(0-0.26, y,
         substitute(paste("T", list(x)), list(x = i)),
         pos = 3)
    for (j in 1:length(tr)) {
        e1 <- exons[[tr[j]]][1]
        e2 <- exons[[tr[j]]][2]
        rect(e1, y-0.25, e2, y+0.25, col = "grey")
        if (i == 1) {
            text(e1, y+0.25, expression(e[s]^i), pos = 3)
            text(e2, y+0.25, expression(e[e]^i), pos = 3)
        }
        text(mean(c(e1, e2)), y, paste0("i = ", tr[j]), cex = .7)
    }
    y <- y - .6
}

y <- y - .4

abline(h = y, lty = "dotted")
text(0-0.26, y, expression(P), pos = 3)
for (i in 1:length(prot)) {
    pr <- prot[[i]]
    rect(pr[1], y - 0.25,
         pr[2], y + 0.25,
         col = "steelblue")
    text(pr[1], y + 0.25, expression(p[s]^j), pos = 3)
    text(pr[2], y + 0.25, expression(p[e]^j), pos = 3)
    text(mean(c(pr[1], pr[2])), y, paste0("j = ", i), cex = .7)
}
y <- y - .75

## concat protein
## center
x <- mean(xlim)
protlen <- sum(sapply(prot, diff))
X0 <- x0 <- x - protlen/2 ## left start

abline(h = y, lty = "dotted")
text(0-0.26, y, expression(P), pos = 3)

for (i in 1:length(prot)) {
    pr <- prot[[i]]
    .pr1 <- x0
    .pr2 <- x0 + (pr[2] - pr[1])
    rect(.pr1, y - 0.25,
         .pr2, y + 0.25,
         col = "steelblue")
    segments(.pr1, y + 0.25, pr[1], y + .75 - .25, lty = "dotted")
    segments(.pr2, y + 0.25, pr[2], y + .75 - .25, lty = "dotted")
    text(mean(c(.pr1,.pr2)), y, paste0("j = ", i), cex = .7)
    x0 <- .pr2
}

text(X0, y, expression(1), pos = 2)
text(X0 + protlen, y, expression(L[P]), pos = 4)

## pos and length
relpeps <- list(c(0.5, 0.29),
                ## 1.% is length of exon 1
                c(1.5 + 0.1, 0.2),
                c(1.5 + 0.85, 0.15),
                ## 1.1 is length of exon 2
                c(1.5 + 1.1 + 0.1, 0.15))

for (i in 1:length(relpeps)) {
    rp <- relpeps[[i]]
    pep <- peps[[i]]
    rect(X0 + rp[1], y - 0.25,
         X0 + rp[1] + rp[2], y + 0.25,
         col = "#FFA50450", lwd = 0)
    segments(X0 + rp[1], y - 0.25,
             pep[1], y - .75 + .25, lty = "dotted")
    segments(X0 + rp[1] + rp[2], y - 0.25,
             pep[2], y - .75 + .25, lty = "dotted")
}
y <- y - .75


abline(h = y, lty = "dotted")
text(0-0.26, y, expression(Pi), pos = 3)
for (i in 1:length(peps)) {
    pep <- peps[[i]]
    rect(pep[1], y - 0.25,
         pep[2], y + 0.25,
         col = "#FFA504FF")
    text(pep[1], y + 0.25, expression(pi[s]^k), pos = 3, cex = .7)
    text(pep[2], y + 0.25, expression(pi[e]^k), pos = 3, cex = .7)
    text(mean(c(pep[1], pep[2])), y-0.35, paste0("k = ", i), cex = .8)
}
```

## Protein and genome data

```{r, echo=FALSE}
data(p)
sp <- seqnames(p)[5]
```

We will use a small object from the `r Biocpkg("Pbase")` package to
illustrate how to retrieve genome coordinates and map a peptides back
to genomic coordinates. In the remainder of this vignette, we will
concentrate on a specific protein, namely `r sp`. The input
information consists of a UniProt identifier and a set of peptides
positions along the protein sequence.

```{r, p, message=FALSE}
library("Pbase")
data(p)
p
seqnames(p)
(sp <- seqnames(p)[5])
```

```{r startend}
pcols(p)[sp, c("start", "end")]
```

We will also require an identifier relating the protein feature of
interest to the genome. Below, we use `r Biocpkg("biomaRt")` to query
the matching HGNC gene symbol, Ensembl gene, transcript and protein
identifiers and UCSC identifier.

```{r bm, cache=TRUE, message=FALSE}
library("biomaRt")
ens <- useMart("ensembl", "hsapiens_gene_ensembl")

bm <- select(ens, keys = sp,
             keytype = "uniprot_swissprot_accession",
             columns = c(
                 "hgnc_symbol",
                 "ensembl_gene_id",
                 "ensembl_transcript_id",
                 "ensembl_peptide_id",
                 "ucsc"))

bm
```

Below, we store the Ensembl transcript and UCSC identifiers in their
own variables `tr` and `ucsc` for convenience.

```{r tr}
tr <- bm$ensembl_transcript_id
ucsc <- bm$ucsc
```

## Genome visualisation with `r Biocpkg("Gviz")`

We will now make use of the `r Biocpkg("Gviz")` infrastructure to
fetch the genomic coordinates of our transcript of interest
(using `r Biocpkg("biomaRt")` under the hood), extract the specific track of
interest and plot it.

Instead of providing the specific start and end coordinates of our
transcript `tr`, we will provide the identifier and the genomic locus
of the gene model will be fetched from Biomart. 

```{r gviz0, cache=TRUE, message=FALSE}
library("Gviz")
bmTrack <- BiomartGeneRegionTrack(transcript = tr,
                                  genome = "hg19")
```

The above query results in `length(bmTrack)` annotation features for
`length(unique(transcript(bmTrack)))` transcripts, including `tr`


```{r annottab}
table(transcript(bmTrack))
stopifnot(tr %in% transcript(bmTrack))
```

We now extract the transcript of interest from all transcript that
exists along the gene model coordinates and coerce the Biomart query
track into a named `GeneRegionTrack`.

```{r gviz1}
bmTracks <- split(bmTrack, transcript(bmTrack))
grTrack <- as(bmTracks[[tr]], "GeneRegionTrack")
names(grTrack) <- tr
```

We can retrieve the exact gene coordinates as a `Granges` object:

```{r bmrng}
ranges(grTrack)
```

Below, we create additional ideogram and axis tracks and produce a
visualisation of our genomic coordinates of interest.

```{r gvizfig, fig.align='center', cache=TRUE}
ideoTrack <- IdeogramTrack(genome = "hg19",
                           chromosome = "chrX")
axisTrack <- GenomeAxisTrack()
plotTracks(list(ideoTrack, axisTrack, grTrack),
           add53 = TRUE, add35 = TRUE)
```

## Using `TranscriptDb` instances

One can also use `TranscriptDb` objects to create the
`GeneRegionTrack`. Below, we use the UCSC annotation to extract our
regions of interest.


```{r txdb0}
library("TxDb.Hsapiens.UCSC.hg19.knownGene")
txdb <- TxDb.Hsapiens.UCSC.hg19.knownGene
txTrack <- GeneRegionTrack(txdb, chromosome = "chrX")
txTracks <- split(txTrack, transcript(txTrack))
grTrack2 <- as(txTracks[[ucsc]], "GeneRegionTrack")
names(grTrack2) <- ucsc
```

and the genomics coordinates as `Granges` object:

```{r txrng}
ranges(grTrack2)
```

## Notable differences 

Note that there exist differences in the 5' and 3' UTR regions between
the two Gene track objects.

```{r compgr}
feature(grTrack)
start(grTrack) - start(grTrack2)
end(grTrack) - end(grTrack2)
```

More substantial differences may arise of one queries UCSC or
Ensembl. Indeed, these two resources might not refer to the same
Genome reference and report different coordinates.

Below, we show how to use the Ensembl Biomart server to retrieve the
genomic coordinates by passing the `ens` Ensembl `Mart` object
(created above when querying for the genomics identifiers) when
creating the Biomart gene region track.

```{r ensgviz}
ens
bmTrack <- BiomartGeneRegionTrack(biomart = ens,
                                  transcript = tr,
                                  genome = "hg19")
bmTracks <- split(bmTrack, transcript(bmTrack))
grTrack3 <- as(bmTracks[[tr]], "GeneRegionTrack")
ranges(grTrack3)
```

## Peptide features

```{r, pp0, echo=FALSE}
pp <- p[sp]
n <- elementLengths(pranges(pp))
pepstring <- paste(unique(pcols(pp)[[1]]$pepseq), collapse = ", ")
```

The peptides that have been experimentally observed are available as
ranges (coordinates) along the protein sequences. For example, below,
we isolate and visualise the `r n` peptides (`r pepstring`) have been
identified for our protein of interest `r sp`.

```{r, pepsfig, fig.align='center'}
pp <- p[sp]
pranges(pp)
plot(pp)
```

The aim of this document is to document the mapping of peptides,
i.e. ranges along a protein sequence to ranges along the genome
reference. In other words, our aim is the convert protein coordinates
to genome coordinates.

## Mapping peptides back to the genome

Additional features of interest (in our case peptides) can be added to
the genomic visualisation using dedicated annotation tracks, that can
be constructed as shown below. 

### Comparing protein and translated DNA sequences

The first check that we want to implement is to verify that we can
regenerate the protein amino acid sequence from the genome regions
that we have extracted. We start by sub-setting only the actual protein
coding regions, i.e ignoring the 5' and 3' untranslated regions of our
Genome Region track.

```{r, protranges}
prng <- ranges(grTrack2)
prng <- prng[prng$feature == "CDS"]
```

We also need the actual genome sequence (so far, we have only dealt
with regions and features). As above, we have used the
`r Biocannopkg("TxDb.Hsapiens.UCSC.hg19.knownGene")` package to identify
genomic coordinates, we want to use the corresponding sequence data,
namely `r Biocannopkg("BSgenome.Hsapiens.UCSC.hg19")`.

```{r, protfromgenome}
library("BSgenome.Hsapiens.UCSC.hg19")
s <- getSeq(BSgenome.Hsapiens.UCSC.hg19, prng)
pptr <- translate(unlist(s))
```

And we align the peptide sequence derived from the genome sequence
`pptr` and the the protein sequence from our original data `pp` (using
the `aa` accessor):

```{r, align}
writePairwiseAlignments(pairwiseAlignment(aa(pp), pptr))
```

### Calculating new coordinates

To calculate the genomic coordinates of peptides we

1) Calculate the contiguous exon coordinates on the cDNA sequence
   `prex`.

2) Calculate the peptide coordinates on the cDNA sequence `peprgn2`
   from the original peptide ranges along the protein sequence.

3) We calculate the indices of the exons in which all the peptides
   start and end on the cDNA sequence `start_ex` and `end_ex`.

4) We infer the coordinates on the genome from the actual peptide
   starting/ending position and exon index on the cDNA sequence, the
   exons coordinates on the cDNA sequences and the matching exons
   coordinates on the genome and store these in an `IRanges` object.

```{r, mapping}
## exons ranges along the protein
j <- cumsum(width(s))
i <- cumsum(c(1, width(s)))[1:length(j)]
prex <- IRanges(start = i, end = j)

peprng <- pranges(pp)[[1]]
## peptide positions on cdna
peprng2 <- IRanges(start = 1 + (start(peprng)-1) * 3,
                   width = width(peprng) * 3)

## find exon and position in prex 
start_ex <- subjectHits(findOverlaps(start(peprng2), prex))
end_ex <- subjectHits(findOverlaps(end(peprng2), prex))

getPos <- function(p, i, prtex = prex, nclex = prng) {
    ## position in cdna
    ## exon index
    start(prng[i]) + (p - start(prtex[i]))
}

peptides_on_genome <- IRanges(start = getPos(start(peprng2), start_ex),
                              end = getPos(end(peprng2), end_ex))

```

### Plotting

Based on the new peptide genomic coordinates, it is now
straightforward to create a new `AnnotationTrack` and add it the the
track visualisation.

```{r, pepcoords, fig.align='center'}
pepTr <- AnnotationTrack(start = start(peptides_on_genome),
                         end = end(peptides_on_genome),
                         chr = "chrX", genome = "hg19",
                         strand = "*",
                         id = pcols(pp)[[1]]$pepseq,
                         name = "pfeatures",
                         col = "steelblue")


plotTracks(list(ideoTrack, axisTrack, grTrack, pepTr),
           groupAnnotation = "id",
           just.group = "below",
           fontsize.group = 9,
           add53 = TRUE, add35 = TRUE)

```

### DetailsAnnotationTrack

Finally, we customise the figure by adding a track with the $MS^2$
spectra. The raw data used to search the protein database an create
`p` are available as an `MSnExp` object. 

```{r, msmsspectra, fig.align='center'}
data(pms)

library("ggplot2")
details <- function(identifier, ...) {
    p <- plot(pms[[as.numeric(identifier)]], full=TRUE, plot=FALSE) + ggtitle("") 
    p <- p + theme_bw() + theme(axis.text.y = element_blank(),
                                axis.text.x = element_blank()) + 
                                labs(x = NULL, y = NULL)
    print(p, newpage=FALSE)
}

deTrack <- AnnotationTrack(start = start(peptides_on_genome),
                           end = end(peptides_on_genome),
                           genome = "hg19", chromosom = "chrX",
                           id = pcols(pp)[[1]]$acquisitionnum,
                           name = "MS2 spectra",
                           stacking = "squish", fun = details)

plotTracks(list(ideoTrack, axisTrack, deTrack, grTrack),
           add53 = TRUE, add35 = TRUE)
```

#### TODO

Check spectra. Describe how data tracks can be used to overlay
additional information, such as quantitation data, identification
scores, coverage, ...

## Session information

```{r, si}
sessionInfo()
```
